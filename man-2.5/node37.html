<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>user_create_lp</TITLE>
<META NAME="description" CONTENT="user_create_lp">
<META NAME="keywords" CONTENT="man">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="man.css">
</HEAD>
<BODY LANG="EN" bgcolor="#FFFFFF" text="#000000">
 <A NAME="tex2html556" HREF="node38.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./next_motif.gif"></A> <A NAME="tex2html554" HREF="node30.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./up_motif.gif"></A> <A NAME="tex2html548" HREF="node36.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./previous_motif.gif"></A>   <A NAME="tex2html1" HREF="man.html"> <IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="external" SRC="contents_motif.gif"  > </A> <A HREF=http://www.branchandcut.org/SYMPHONY>Back to SYMPHONY Home Page</A><BR>
<B> Next:</B> <A NAME="tex2html557" HREF="node38.html">user_get_upper_bounds</A>
<B>Up:</B> <A NAME="tex2html555" HREF="node30.html">User-written functions of the </A>
<B> Previous:</B> <A NAME="tex2html549" HREF="node36.html">user_free_lp</A>
<BR> <P>
<H3><A NAME="SECTION00022400000000000000">user_create_lp</A></H3>
<P>
<PRE>int user_create_lp(void *user, int varnum, var_desc **vars, int
                   numrows, int cutnum, cut_data **cuts, int *nz,
                   int **matbeg, int **matind, double **matval, 
                   double **obj, double **rhs, char **sense, 
                   double **rngval, int *maxn, int *maxm, 
                   int *maxnz, int *allocn, int *allocm, int *allocnz)</PRE>
<P>
<DL ><DT><STRONG>Description:</STRONG>
<DD>
<P>
Based on the instance data contained in the user data structure and
the list of cuts and variables that are active in the
current subproblem, the user has to create the initial LP relaxation
for the search node. The matrix of the LP problem must contain the
variables whose user indices are listed in <TT>vars</TT> (in the same
order) and at least the base constraints. <BR> 
<BR> 
An LP is defined by a matrix of constraints, an objective function,
and bounds on both the right hand side values of the constraints and
on the variables. If the problem has <I>n</I> variables and <I>m</I>
constraints, the constraints are given by a constraint coefficient
matrix of size <I>m x n</I> (described in the next paragraph). The sense of
each constraint, the right hand side values and bounds on the right
hand side (called <EM>range</EM>) are vectors are of size <I>m</I>. The
objective function coefficients and the lower and upper bounds on the
variables are vectors of length <I>n</I>. The sense of each constraint can
be either 'L' ( <IMG WIDTH=11 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline2104" SRC="img30.gif"  > ), 'E' (=), 'G' ( <IMG WIDTH=11 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline2108" SRC="img31.gif"  > ) or 'R' (ranged). For
non-ranged rows the range value is <TT>0</TT>, for a ranged row the range
value must be non-negative and the constraint means that the row
activity level has to be between the right hand side value and the
right hand side increased by the range value. <BR> 
<BR> 
Since the coefficient matrix is very often sparse, only the nonzero
entries are stored. Each entry of the matrix has a column index, a row
index and a coefficient value associated with it. An LP matrix is
specified in the form of the three arrays <TT>*matval</TT>, <TT>
*matind</TT>, and <TT>*matbeg</TT>. The array <TT>*matval</TT> contains the
values of the nonzero entries of the matrix in <EM>column order</EM>;
that is, all the entries for the  <IMG WIDTH=23 HEIGHT=15 ALIGN=BOTTOM ALT="tex2html_wrap_inline2126" SRC="img36.gif"  >  column come first, then the
entries for the  <IMG WIDTH=21 HEIGHT=12 ALIGN=BOTTOM ALT="tex2html_wrap_inline2128" SRC="img37.gif"  >  column, etc. The row index corresponding to
each entry of <TT>*matval</TT> is listed in <TT>*matind</TT> (both of them
are of length <I>nz</I>, the number of nonzero entries in the matrix).
Finally, <TT>*matbeg</TT> contains the starting positions of each of the
columns in <TT>*matval</TT> and <TT>*matind</TT>. Thus, <TT>(*matbeg)[i]</TT>
is the position of the first entry of column <I>i</I> in both <TT>*matval</TT>
and <TT>*matind</TT>). By convention <TT>*matbeg</TT> is allocated to be of
length <I>n</I>+1, with <TT>(*matbeg)[n]</TT> containing the position after
the very last entry in <TT>*matval</TT> and <TT>*matind</TT> (so it is very
conveniently equal to <I>nz</I>). This representation of a matrix is known
as a <EM>column ordered</EM> or <EM>column major</EM> representation.<BR> 
<BR> 
The arrays that are passed in can be overwritten and have already been
previously allocated for the lengths indicated (see the description of
arguments below). Therefore, if they are big enough, the user need not
reallocate them. If the max lengths are not big enough then she has to
free the corresponding arrays and allocate them again. In this case
she <EM>must</EM> return the allocated size of the array to avoid further
reallocation. If the user plans to utilize dynamic column and/or cut
generation, arrays should be allocated large enough to allow for
reasonable growth of the matrix or unnecessary reallocations will
result. In order to accommodate <TT>*maxn</TT> variables, arrays must be
allocated to size <TT>*allocn = *maxn + *maxm +1</TT> and <TT>*allocnz =
*maxnz + *maxm</TT> because of the extra space required by the LP solver
for slack and artificial variables.
<P>
<DT><STRONG>Arguments:</STRONG>
<DD>
<P>
<P> <IMG WIDTH=697 HEIGHT=596 ALIGN=BOTTOM ALT="tabular1336" SRC="img38.gif"  > <P>
<P>
<DT><STRONG>Return values:</STRONG>
<DD>
<P>
<P> <IMG WIDTH=696 HEIGHT=81 ALIGN=BOTTOM ALT="tabular1338" SRC="img39.gif"  > <P>
<P>
<DT><STRONG>Post-processing:</STRONG>
<DD>
<P>
The extra constraints are added to the matrix by calling the 
<A HREF="node49.html#user_unpack_cuts"><TT>user_unpack_cuts()</TT></A> subroutine and 
then adding the corresponding rows to the matrix. This is easier for
the user to implement, but less efficient than adding the cuts at the
time the original matrix was being constructed.
<P>
<DT><STRONG>Wrapper invoked from:</STRONG>
<DD> <TT>process_chain()</TT> which is
invoked when setting up a the initial search node in a chain.
<P>
 </DL>
<HR><A NAME="tex2html556" HREF="node38.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./next_motif.gif"></A> <A NAME="tex2html554" HREF="node30.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./up_motif.gif"></A> <A NAME="tex2html548" HREF="node36.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./previous_motif.gif"></A>   <A NAME="tex2html1" HREF="man.html"> <IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="external" SRC="contents_motif.gif"  > </A><BR>
<B> Next:</B> <A NAME="tex2html557" HREF="node38.html">user_get_upper_bounds</A>
<B>Up:</B> <A NAME="tex2html555" HREF="node30.html">User-written functions of the </A>
<B> Previous:</B> <A NAME="tex2html549" HREF="node36.html">user_free_lp</A>
<P><ADDRESS>
<I>Ted Ralphs <BR>
Fri Feb 11 13:47:59 CST 2000</I>
</ADDRESS>
</BODY>
</HTML>
